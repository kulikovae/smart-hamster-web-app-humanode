{"ast":null,"code":"'use strict';\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account2FA = exports.AccountMultisig = exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst account_1 = require(\"./account\");\n\nconst format_1 = require(\"./utils/format\");\n\nconst key_pair_1 = require(\"./utils/key_pair\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst providers_1 = require(\"./providers\");\n\nconst web_1 = require(\"./utils/web\");\n\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default((0, format_1.parseNearAmount)('1')); // TODO: Different gas value for different requests (can reduce gas usage dramatically)\n\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\nvar MultisigDeleteRequestRejectionError;\n\n(function (MultisigDeleteRequestRejectionError) {\n  MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n  MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n  MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n  MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n  MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\n\nvar MultisigStateStatus;\n\n(function (MultisigStateStatus) {\n  MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n  MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n  MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n  MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\n\nvar MultisigCodeStatus;\n\n(function (MultisigCodeStatus) {\n  MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n  MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n  MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {})); // in memory request cache for node w/o localStorage\n\n\nconst storageFallback = {\n  [exports.MULTISIG_STORAGE_KEY]: null\n};\n\nclass AccountMultisig extends account_1.Account {\n  constructor(connection, accountId, options) {\n    super(connection, accountId);\n    this.storage = options.storage;\n    this.onAddRequestResult = options.onAddRequestResult;\n  }\n\n  signAndSendTransactionWithAccount(receiverId, actions) {\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return _super.signAndSendTransaction.call(this, {\n        receiverId,\n        actions\n      });\n    });\n  }\n\n  signAndSendTransaction(_ref) {\n    let {\n      receiverId,\n      actions\n    } = _ref;\n\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const args = Buffer.from(JSON.stringify({\n        request: {\n          receiver_id: receiverId,\n          actions: convertActions(actions, accountId, receiverId)\n        }\n      }));\n      let result;\n\n      try {\n        result = yield _super.signAndSendTransaction.call(this, {\n          receiverId: accountId,\n          actions: [(0, transaction_1.functionCall)('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n      } catch (e) {\n        if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n          yield this.deleteUnconfirmedRequests();\n          return yield this.signAndSendTransaction({\n            receiverId,\n            actions\n          });\n        }\n\n        throw e;\n      } // TODO: Are following even needed? Seems like it throws on error already\n\n\n      if (!result.status) {\n        throw new Error('Request failed');\n      }\n\n      const status = Object.assign({}, result.status);\n\n      if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n        throw new Error('Request failed');\n      }\n\n      this.setRequest({\n        accountId,\n        actions,\n        requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n      });\n\n      if (this.onAddRequestResult) {\n        yield this.onAddRequestResult(result);\n      } // NOTE there is no await on purpose to avoid blocking for 2fa\n\n\n      this.deleteUnconfirmedRequests();\n      return result;\n    });\n  }\n  /*\n   * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n   * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n   * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n   */\n\n\n  checkMultisigCodeAndStateStatus(contractBytes) {\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const u32_max = 4294967295;\n      const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n\n      try {\n        if (contractBytes) {\n          yield _super.signAndSendTransaction.call(this, {\n            receiverId: this.accountId,\n            actions: [(0, transaction_1.deployContract)(contractBytes), (0, transaction_1.functionCall)('delete_request', {\n              request_id: u32_max\n            }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n          });\n        } else {\n          yield this.deleteRequest(u32_max);\n        }\n\n        return {\n          codeStatus: MultisigCodeStatus.VALID_CODE,\n          stateStatus: MultisigStateStatus.VALID_STATE\n        };\n      } catch (e) {\n        if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n          return {\n            codeStatus: validCodeStatusIfNoDeploy,\n            stateStatus: MultisigStateStatus.INVALID_STATE\n          };\n        } else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n          return {\n            codeStatus: validCodeStatusIfNoDeploy,\n            stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED\n          };\n        } else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n          return {\n            codeStatus: validCodeStatusIfNoDeploy,\n            stateStatus: MultisigStateStatus.VALID_STATE\n          };\n        } else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n          // not reachable if transaction included a deploy\n          return {\n            codeStatus: MultisigCodeStatus.INVALID_CODE,\n            stateStatus: MultisigStateStatus.UNKNOWN_STATE\n          };\n        }\n\n        throw e;\n      }\n    });\n  }\n\n  deleteRequest(request_id) {\n    return super.signAndSendTransaction({\n      receiverId: this.accountId,\n      actions: [(0, transaction_1.functionCall)('delete_request', {\n        request_id\n      }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n    });\n  }\n\n  deleteAllRequests() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request_ids = yield this.getRequestIds();\n\n      if (request_ids.length) {\n        yield Promise.all(request_ids.map(id => this.deleteRequest(id)));\n      }\n    });\n  }\n\n  deleteUnconfirmedRequests() {\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Delete in batch, don't delete unexpired\n      // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n      const request_ids = yield this.getRequestIds();\n      const {\n        requestId\n      } = this.getRequest();\n\n      for (const requestIdToDelete of request_ids) {\n        if (requestIdToDelete == requestId) {\n          continue;\n        }\n\n        try {\n          yield _super.signAndSendTransaction.call(this, {\n            receiverId: this.accountId,\n            actions: [(0, transaction_1.functionCall)('delete_request', {\n              request_id: requestIdToDelete\n            }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n          });\n        } catch (e) {\n          console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n        }\n      }\n    });\n  } // helpers\n\n\n  getRequestIds() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Read requests from state to allow filtering by expiration time\n      // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n      return this.viewFunction(this.accountId, 'list_request_ids');\n    });\n  }\n\n  getRequest() {\n    if (this.storage) {\n      return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');\n    }\n\n    return storageFallback[exports.MULTISIG_STORAGE_KEY];\n  }\n\n  setRequest(data) {\n    if (this.storage) {\n      return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n    }\n\n    storageFallback[exports.MULTISIG_STORAGE_KEY] = data;\n  }\n\n}\n\nexports.AccountMultisig = AccountMultisig;\n\nclass Account2FA extends AccountMultisig {\n  constructor(connection, accountId, options) {\n    super(connection, accountId, options);\n    this.helperUrl = 'https://helper.testnet.near.org';\n    this.helperUrl = options.helperUrl || this.helperUrl;\n    this.storage = options.storage;\n    this.sendCode = options.sendCode || this.sendCodeDefault;\n    this.getCode = options.getCode || this.getCodeDefault;\n    this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n    this.onConfirmResult = options.onConfirmResult;\n  }\n  /**\n   * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n   * @see {@link JsonRpcProvider.sendTransaction}\n   */\n\n\n  signAndSendTransaction(_ref2) {\n    let {\n      receiverId,\n      actions\n    } = _ref2;\n\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.signAndSendTransaction.call(this, {\n        receiverId,\n        actions\n      }); // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n\n      yield this.sendCode();\n      const result = yield this.promptAndVerify();\n\n      if (this.onConfirmResult) {\n        yield this.onConfirmResult(result);\n      }\n\n      return result;\n    });\n  } // default helpers for CH deployments of multisig\n\n\n  deployMultisig(contractBytes) {\n    const _super = Object.create(null, {\n      signAndSendTransactionWithAccount: {\n        get: () => super.signAndSendTransactionWithAccount\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const seedOrLedgerKey = (yield this.getRecoveryMethods()).data.filter(_ref3 => {\n        let {\n          kind,\n          publicKey\n        } = _ref3;\n        return (kind === 'phrase' || kind === 'ledger') && publicKey !== null;\n      }).map(rm => rm.publicKey);\n      const fak2lak = (yield this.getAccessKeys()).filter(_ref4 => {\n        let {\n          public_key,\n          access_key: {\n            permission\n          }\n        } = _ref4;\n        return permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key);\n      }).map(ak => ak.public_key).map(toPK);\n      const confirmOnlyKey = toPK((yield this.postSignedJson('/2fa/getAccessKey', {\n        accountId\n      })).publicKey);\n      const newArgs = Buffer.from(JSON.stringify({\n        'num_confirmations': 2\n      }));\n      const actions = [...fak2lak.map(pk => (0, transaction_1.deleteKey)(pk)), ...fak2lak.map(pk => (0, transaction_1.addKey)(pk, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CHANGE_METHODS, null))), (0, transaction_1.addKey)(confirmOnlyKey, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CONFIRM_METHODS, null)), (0, transaction_1.deployContract)(contractBytes)];\n      const newFunctionCallActionBatch = actions.concat((0, transaction_1.functionCall)('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));\n      console.log('deploying multisig contract for', accountId);\n      const {\n        stateStatus: multisigStateStatus\n      } = yield this.checkMultisigCodeAndStateStatus(contractBytes);\n\n      switch (multisigStateStatus) {\n        case MultisigStateStatus.STATE_NOT_INITIALIZED:\n          return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);\n\n        case MultisigStateStatus.VALID_STATE:\n          return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);\n\n        case MultisigStateStatus.INVALID_STATE:\n          throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n\n        default:\n          throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n      }\n    });\n  }\n\n  disableWithFAK(_ref5) {\n    let {\n      contractBytes,\n      cleanupContractBytes\n    } = _ref5;\n    return __awaiter(this, void 0, void 0, function* () {\n      let cleanupActions = [];\n\n      if (cleanupContractBytes) {\n        yield this.deleteAllRequests().catch(e => e);\n        cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);\n      }\n\n      const keyConversionActions = yield this.get2faDisableKeyConversionActions();\n      const actions = [...cleanupActions, ...keyConversionActions, (0, transaction_1.deployContract)(contractBytes)];\n      const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);\n\n      if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n        throw new providers_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n      }\n\n      return this.signAndSendTransactionWithAccount(this.accountId, actions);\n    });\n  }\n\n  get2faDisableCleanupActions(cleanupContractBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentAccountState = yield this.viewState('').catch(error => {\n        const cause = error.cause && error.cause.name;\n\n        if (cause == 'NO_CONTRACT_CODE') {\n          return [];\n        }\n\n        throw cause == 'TOO_LARGE_CONTRACT_STATE' ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState') : error;\n      });\n      const currentAccountStateKeys = currentAccountState.map(_ref6 => {\n        let {\n          key\n        } = _ref6;\n        return key.toString('base64');\n      });\n      return currentAccountState.length ? [(0, transaction_1.deployContract)(cleanupContractBytes), (0, transaction_1.functionCall)('clean', {\n        keys: currentAccountStateKeys\n      }, exports.MULTISIG_GAS, new bn_js_1.default('0'))] : [];\n    });\n  }\n\n  get2faDisableKeyConversionActions() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const accessKeys = yield this.getAccessKeys();\n      const lak2fak = accessKeys.filter(_ref7 => {\n        let {\n          access_key\n        } = _ref7;\n        return access_key.permission !== 'FullAccess';\n      }).filter(_ref8 => {\n        let {\n          access_key\n        } = _ref8;\n        const perm = access_key.permission.FunctionCall;\n        return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes('add_request_and_confirm');\n      });\n      const confirmOnlyKey = key_pair_1.PublicKey.from((yield this.postSignedJson('/2fa/getAccessKey', {\n        accountId\n      })).publicKey);\n      return [(0, transaction_1.deleteKey)(confirmOnlyKey), ...lak2fak.map(_ref9 => {\n        let {\n          public_key\n        } = _ref9;\n        return (0, transaction_1.deleteKey)(key_pair_1.PublicKey.from(public_key));\n      }), ...lak2fak.map(_ref10 => {\n        let {\n          public_key\n        } = _ref10;\n        return (0, transaction_1.addKey)(key_pair_1.PublicKey.from(public_key), (0, transaction_1.fullAccessKey)());\n      })];\n    });\n  }\n  /**\n   * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n   * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n   * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n   */\n\n\n  disable(contractBytes, cleanupContractBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        stateStatus\n      } = yield this.checkMultisigCodeAndStateStatus();\n\n      if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {\n        throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n      }\n\n      let deleteAllRequestsError;\n      yield this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n      const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n        if (e.type === 'ContractHasExistingState') {\n          throw deleteAllRequestsError || e;\n        }\n\n        throw e;\n      });\n      const actions = [...cleanupActions, ...(yield this.get2faDisableKeyConversionActions()), (0, transaction_1.deployContract)(contractBytes)];\n      console.log('disabling 2fa for', this.accountId);\n      return yield this.signAndSendTransaction({\n        receiverId: this.accountId,\n        actions\n      });\n    });\n  }\n\n  sendCodeDefault() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const {\n        requestId\n      } = this.getRequest();\n      const method = yield this.get2faMethod();\n      yield this.postSignedJson('/2fa/send', {\n        accountId,\n        method,\n        requestId\n      });\n      return requestId;\n    });\n  }\n\n  getCodeDefault() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n    });\n  }\n\n  promptAndVerify() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const method = yield this.get2faMethod();\n      const securityCode = yield this.getCode(method);\n\n      try {\n        const result = yield this.verifyCode(securityCode); // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n\n        return result;\n      } catch (e) {\n        console.warn('Error validating security code:', e);\n\n        if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n          return yield this.promptAndVerify();\n        }\n\n        throw e;\n      }\n    });\n  }\n\n  verifyCodeDefault(securityCode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const request = this.getRequest();\n\n      if (!request) {\n        throw new Error('no request pending');\n      }\n\n      const {\n        requestId\n      } = request;\n      return yield this.postSignedJson('/2fa/verify', {\n        accountId,\n        securityCode,\n        requestId\n      });\n    });\n  }\n\n  getRecoveryMethods() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      return {\n        accountId,\n        data: yield this.postSignedJson('/account/recoveryMethods', {\n          accountId\n        })\n      };\n    });\n  }\n\n  get2faMethod() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        data\n      } = yield this.getRecoveryMethods();\n\n      if (data && data.length) {\n        data = data.find(m => m.kind.indexOf('2fa-') === 0);\n      }\n\n      if (!data) return null;\n      const {\n        kind,\n        detail\n      } = data;\n      return {\n        kind,\n        detail\n      };\n    });\n  }\n\n  signatureFor() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        accountId\n      } = this;\n      const block = yield this.connection.provider.block({\n        finality: 'final'\n      });\n      const blockNumber = block.header.height.toString();\n      const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n      const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n      return {\n        blockNumber,\n        blockNumberSignature\n      };\n    });\n  }\n\n  postSignedJson(path, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield (0, web_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), yield this.signatureFor())));\n    });\n  }\n\n}\n\nexports.Account2FA = Account2FA; // helpers\n\nconst toPK = pk => key_pair_1.PublicKey.from(pk);\n\nconst convertPKForContract = pk => pk.toString().replace('ed25519:', '');\n\nconst convertActions = (actions, accountId, receiverId) => actions.map(a => {\n  const type = a.enum;\n  const {\n    gas,\n    publicKey,\n    methodName,\n    args,\n    deposit,\n    accessKey,\n    code\n  } = a[type];\n  const action = {\n    type: type[0].toUpperCase() + type.substr(1),\n    gas: gas && gas.toString() || undefined,\n    public_key: publicKey && convertPKForContract(publicKey) || undefined,\n    method_name: methodName,\n    args: args && Buffer.from(args).toString('base64') || undefined,\n    code: code && Buffer.from(code).toString('base64') || undefined,\n    amount: deposit && deposit.toString() || undefined,\n    deposit: deposit && deposit.toString() || '0',\n    permission: undefined\n  };\n\n  if (accessKey) {\n    if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n      action.permission = {\n        receiver_id: accountId,\n        allowance: exports.MULTISIG_ALLOWANCE.toString(),\n        method_names: exports.MULTISIG_CHANGE_METHODS\n      };\n    }\n\n    if (accessKey.permission.enum === 'functionCall') {\n      const {\n        receiverId: receiver_id,\n        methodNames: method_names,\n        allowance\n      } = accessKey.permission.functionCall;\n      action.permission = {\n        receiver_id,\n        allowance: allowance && allowance.toString() || undefined,\n        method_names\n      };\n    }\n  }\n\n  return action;\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","Account2FA","AccountMultisig","MultisigStateStatus","MultisigDeleteRequestRejectionError","MULTISIG_CONFIRM_METHODS","MULTISIG_CHANGE_METHODS","MULTISIG_DEPOSIT","MULTISIG_GAS","MULTISIG_ALLOWANCE","MULTISIG_STORAGE_KEY","bn_js_1","require","account_1","format_1","key_pair_1","transaction_1","providers_1","web_1","default","parseNearAmount","MultisigCodeStatus","storageFallback","Account","constructor","connection","accountId","options","storage","onAddRequestResult","signAndSendTransactionWithAccount","receiverId","actions","_super","create","signAndSendTransaction","get","call","args","Buffer","from","JSON","stringify","request","receiver_id","convertActions","functionCall","toString","includes","deleteUnconfirmedRequests","status","Error","assign","SuccessValue","setRequest","requestId","parseInt","checkMultisigCodeAndStateStatus","contractBytes","u32_max","validCodeStatusIfNoDeploy","UNKNOWN_CODE","VALID_CODE","deployContract","request_id","deleteRequest","codeStatus","stateStatus","VALID_STATE","RegExp","CANNOT_DESERIALIZE_STATE","test","kind","ExecutionError","INVALID_STATE","MULTISIG_NOT_INITIALIZED","STATE_NOT_INITIALIZED","NO_SUCH_REQUEST","METHOD_NOT_FOUND","message","INVALID_CODE","UNKNOWN_STATE","deleteAllRequests","request_ids","getRequestIds","length","all","map","id","getRequest","requestIdToDelete","console","warn","viewFunction","parse","getItem","data","setItem","helperUrl","sendCode","sendCodeDefault","getCode","getCodeDefault","verifyCode","verifyCodeDefault","onConfirmResult","promptAndVerify","deployMultisig","seedOrLedgerKey","getRecoveryMethods","filter","publicKey","rm","fak2lak","getAccessKeys","public_key","access_key","permission","ak","toPK","confirmOnlyKey","postSignedJson","newArgs","pk","deleteKey","addKey","functionCallAccessKey","newFunctionCallActionBatch","concat","log","multisigStateStatus","TypedError","networkId","disableWithFAK","cleanupContractBytes","cleanupActions","catch","get2faDisableCleanupActions","keyConversionActions","get2faDisableKeyConversionActions","accessKeyInfo","findAccessKey","accessKey","currentAccountState","viewState","error","cause","name","currentAccountStateKeys","key","keys","accessKeys","lak2fak","perm","FunctionCall","method_names","PublicKey","fullAccessKey","disable","deleteAllRequestsError","type","method","get2faMethod","securityCode","find","m","indexOf","detail","signatureFor","block","provider","finality","blockNumber","header","height","signed","signer","signMessage","blockNumberSignature","signature","path","body","fetchJson","convertPKForContract","replace","a","enum","gas","methodName","deposit","code","action","toUpperCase","substr","undefined","method_name","amount","allowance","methodNames"],"sources":["/Users/loyanix/projects/smart-hamster-web-app/node_modules/near-api-js/lib/account_multisig.js"],"sourcesContent":["'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account2FA = exports.AccountMultisig = exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst account_1 = require(\"./account\");\nconst format_1 = require(\"./utils/format\");\nconst key_pair_1 = require(\"./utils/key_pair\");\nconst transaction_1 = require(\"./transaction\");\nconst providers_1 = require(\"./providers\");\nconst web_1 = require(\"./utils/web\");\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default((0, format_1.parseNearAmount)('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [exports.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    signAndSendTransactionWithAccount(receiverId, actions) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.signAndSendTransaction.call(this, { receiverId, actions });\n        });\n    }\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const args = Buffer.from(JSON.stringify({\n                request: {\n                    receiver_id: receiverId,\n                    actions: convertActions(actions, accountId, receiverId)\n                }\n            }));\n            let result;\n            try {\n                result = yield _super.signAndSendTransaction.call(this, {\n                    receiverId: accountId,\n                    actions: [\n                        (0, transaction_1.functionCall)('add_request_and_confirm', args, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            catch (e) {\n                if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                    yield this.deleteUnconfirmedRequests();\n                    return yield this.signAndSendTransaction({ receiverId, actions });\n                }\n                throw e;\n            }\n            // TODO: Are following even needed? Seems like it throws on error already\n            if (!result.status) {\n                throw new Error('Request failed');\n            }\n            const status = Object.assign({}, result.status);\n            if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n                throw new Error('Request failed');\n            }\n            this.setRequest({\n                accountId,\n                actions,\n                requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n            });\n            if (this.onAddRequestResult) {\n                yield this.onAddRequestResult(result);\n            }\n            // NOTE there is no await on purpose to avoid blocking for 2fa\n            this.deleteUnconfirmedRequests();\n            return result;\n        });\n    }\n    /*\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     */\n    checkMultisigCodeAndStateStatus(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const u32_max = 4294967295;\n            const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n            try {\n                if (contractBytes) {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId, actions: [\n                            (0, transaction_1.deployContract)(contractBytes),\n                            (0, transaction_1.functionCall)('delete_request', { request_id: u32_max }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)\n                        ]\n                    });\n                }\n                else {\n                    yield this.deleteRequest(u32_max);\n                }\n                return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: MultisigStateStatus.VALID_STATE };\n            }\n            catch (e) {\n                if (new RegExp(MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.INVALID_STATE };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.STATE_NOT_INITIALIZED };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: MultisigStateStatus.VALID_STATE };\n                }\n                else if (new RegExp(MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                    // not reachable if transaction included a deploy\n                    return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: MultisigStateStatus.UNKNOWN_STATE };\n                }\n                throw e;\n            }\n        });\n    }\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [(0, transaction_1.functionCall)('delete_request', { request_id }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n        });\n    }\n    deleteAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request_ids = yield this.getRequestIds();\n            if (request_ids.length) {\n                yield Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n            }\n        });\n    }\n    deleteUnconfirmedRequests() {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Delete in batch, don't delete unexpired\n            // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n            const request_ids = yield this.getRequestIds();\n            const { requestId } = this.getRequest();\n            for (const requestIdToDelete of request_ids) {\n                if (requestIdToDelete == requestId) {\n                    continue;\n                }\n                try {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId,\n                        actions: [(0, transaction_1.functionCall)('delete_request', { request_id: requestIdToDelete }, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT)]\n                    });\n                }\n                catch (e) {\n                    console.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n                }\n            }\n        });\n    }\n    // helpers\n    getRequestIds() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Read requests from state to allow filtering by expiration time\n            // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n            return this.viewFunction(this.accountId, 'list_request_ids');\n        });\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(exports.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[exports.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(exports.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[exports.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nclass Account2FA extends AccountMultisig {\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = 'https://helper.testnet.near.org';\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link JsonRpcProvider.sendTransaction}\n     */\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n            // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n            yield this.sendCode();\n            const result = yield this.promptAndVerify();\n            if (this.onConfirmResult) {\n                yield this.onConfirmResult(result);\n            }\n            return result;\n        });\n    }\n    // default helpers for CH deployments of multisig\n    deployMultisig(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const seedOrLedgerKey = (yield this.getRecoveryMethods()).data\n                .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n                .map((rm) => rm.publicKey);\n            const fak2lak = (yield this.getAccessKeys())\n                .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n                .map((ak) => ak.public_key)\n                .map(toPK);\n            const confirmOnlyKey = toPK((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n            const actions = [\n                ...fak2lak.map((pk) => (0, transaction_1.deleteKey)(pk)),\n                ...fak2lak.map((pk) => (0, transaction_1.addKey)(pk, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CHANGE_METHODS, null))),\n                (0, transaction_1.addKey)(confirmOnlyKey, (0, transaction_1.functionCallAccessKey)(accountId, exports.MULTISIG_CONFIRM_METHODS, null)),\n                (0, transaction_1.deployContract)(contractBytes),\n            ];\n            const newFunctionCallActionBatch = actions.concat((0, transaction_1.functionCall)('new', newArgs, exports.MULTISIG_GAS, exports.MULTISIG_DEPOSIT));\n            console.log('deploying multisig contract for', accountId);\n            const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);\n            switch (multisigStateStatus) {\n                case MultisigStateStatus.STATE_NOT_INITIALIZED:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);\n                case MultisigStateStatus.VALID_STATE:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);\n                case MultisigStateStatus.INVALID_STATE:\n                    throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n                default:\n                    throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n        });\n    }\n    disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupActions = [];\n            if (cleanupContractBytes) {\n                yield this.deleteAllRequests().catch(e => e);\n                cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);\n            }\n            const keyConversionActions = yield this.get2faDisableKeyConversionActions();\n            const actions = [\n                ...cleanupActions,\n                ...keyConversionActions,\n                (0, transaction_1.deployContract)(contractBytes)\n            ];\n            const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);\n            if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n                throw new providers_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n            }\n            return this.signAndSendTransactionWithAccount(this.accountId, actions);\n        });\n    }\n    get2faDisableCleanupActions(cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentAccountState = yield this.viewState('').catch(error => {\n                const cause = error.cause && error.cause.name;\n                if (cause == 'NO_CONTRACT_CODE') {\n                    return [];\n                }\n                throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                    ? new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                    : error;\n            });\n            const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n            return currentAccountState.length ? [\n                (0, transaction_1.deployContract)(cleanupContractBytes),\n                (0, transaction_1.functionCall)('clean', { keys: currentAccountStateKeys }, exports.MULTISIG_GAS, new bn_js_1.default('0'))\n            ] : [];\n        });\n    }\n    get2faDisableKeyConversionActions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const accessKeys = yield this.getAccessKeys();\n            const lak2fak = accessKeys\n                .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n                .filter(({ access_key }) => {\n                const perm = access_key.permission.FunctionCall;\n                return perm.receiver_id === accountId &&\n                    perm.method_names.length === 4 &&\n                    perm.method_names.includes('add_request_and_confirm');\n            });\n            const confirmOnlyKey = key_pair_1.PublicKey.from((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            return [\n                (0, transaction_1.deleteKey)(confirmOnlyKey),\n                ...lak2fak.map(({ public_key }) => (0, transaction_1.deleteKey)(key_pair_1.PublicKey.from(public_key))),\n                ...lak2fak.map(({ public_key }) => (0, transaction_1.addKey)(key_pair_1.PublicKey.from(public_key), (0, transaction_1.fullAccessKey)()))\n            ];\n        });\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-cleanup/res/state_cleanup.wasm?raw=true}\n     */\n    disable(contractBytes, cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();\n            if (stateStatus !== MultisigStateStatus.VALID_STATE && stateStatus !== MultisigStateStatus.STATE_NOT_INITIALIZED) {\n                throw new providers_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n            let deleteAllRequestsError;\n            yield this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n            const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n                if (e.type === 'ContractHasExistingState') {\n                    throw deleteAllRequestsError || e;\n                }\n                throw e;\n            });\n            const actions = [\n                ...cleanupActions,\n                ...(yield this.get2faDisableKeyConversionActions()),\n                (0, transaction_1.deployContract)(contractBytes),\n            ];\n            console.log('disabling 2fa for', this.accountId);\n            return yield this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions\n            });\n        });\n    }\n    sendCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const { requestId } = this.getRequest();\n            const method = yield this.get2faMethod();\n            yield this.postSignedJson('/2fa/send', {\n                accountId,\n                method,\n                requestId,\n            });\n            return requestId;\n        });\n    }\n    getCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n        });\n    }\n    promptAndVerify() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const method = yield this.get2faMethod();\n            const securityCode = yield this.getCode(method);\n            try {\n                const result = yield this.verifyCode(securityCode);\n                // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n                return result;\n            }\n            catch (e) {\n                console.warn('Error validating security code:', e);\n                if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                    return yield this.promptAndVerify();\n                }\n                throw e;\n            }\n        });\n    }\n    verifyCodeDefault(securityCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const request = this.getRequest();\n            if (!request) {\n                throw new Error('no request pending');\n            }\n            const { requestId } = request;\n            return yield this.postSignedJson('/2fa/verify', {\n                accountId,\n                securityCode,\n                requestId\n            });\n        });\n    }\n    getRecoveryMethods() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            return {\n                accountId,\n                data: yield this.postSignedJson('/account/recoveryMethods', { accountId })\n            };\n        });\n    }\n    get2faMethod() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { data } = yield this.getRecoveryMethods();\n            if (data && data.length) {\n                data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n            }\n            if (!data)\n                return null;\n            const { kind, detail } = data;\n            return { kind, detail };\n        });\n    }\n    signatureFor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockNumber = block.header.height.toString();\n            const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n            const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n            return { blockNumber, blockNumberSignature };\n        });\n    }\n    postSignedJson(path, body) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield (0, web_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), (yield this.signatureFor()))));\n        });\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => key_pair_1.PublicKey.from(pk);\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: exports.MULTISIG_ALLOWANCE.toString(),\n                method_names: exports.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}