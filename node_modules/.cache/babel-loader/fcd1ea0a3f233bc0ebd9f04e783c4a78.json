{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedWalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\n\nconst account_1 = require(\"./account\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst utils_1 = require(\"./utils\");\n\nconst borsh_1 = require(\"borsh\");\n\nconst borsh_2 = require(\"borsh\");\n\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSignedIn()) return wallet.requestSignIn()\n * ```\n */\n\nclass WalletConnection {\n  constructor(near, appKeyPrefix) {\n    if (typeof window === 'undefined') {\n      return new Proxy(this, {\n        get(target, property) {\n          if (property === 'isSignedIn') {\n            return () => false;\n          }\n\n          if (property === 'getAccountId') {\n            return () => '';\n          }\n\n          if (target[property] && typeof target[property] === 'function') {\n            return () => {\n              throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');\n            };\n          }\n\n          return target[property];\n        }\n\n      });\n    }\n\n    this._near = near;\n    const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n    this._keyStore = near.connection.signer.keyStore;\n    this._authData = authData || {\n      allKeys: []\n    };\n    this._authDataKey = authDataKey;\n\n    if (!this.isSignedIn()) {\n      this._completeSignInPromise = this._completeSignInWithAccessKey();\n    }\n  }\n  /**\n   * Returns true, if this WalletConnection is authorized with the wallet.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.isSignedIn();\n   * ```\n   */\n\n\n  isSignedIn() {\n    return !!this._authData.accountId;\n  }\n  /**\n   * Returns promise of completing signing in after redirecting from wallet\n   * @example\n   * ```js\n   * // on login callback page\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.isSignedIn(); // false\n   * await wallet.isSignedInAsync(); // true\n   * ```\n   */\n\n\n  isSignedInAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._completeSignInPromise) {\n        return this.isSignedIn();\n      }\n\n      yield this._completeSignInPromise;\n      return this.isSignedIn();\n    });\n  }\n  /**\n   * Returns authorized Account ID.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.getAccountId();\n   * ```\n   */\n\n\n  getAccountId() {\n    return this._authData.accountId || '';\n  }\n  /**\n   * Redirects current page to the wallet authentication page.\n   * @param options An optional options object\n   * @param options.contractId The NEAR account where the contract is deployed\n   * @param options.successUrl URL to redirect upon success. Default: current url\n   * @param options.failureUrl URL to redirect upon failure. Default: current url\n   *\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * // redirects to the NEAR Wallet\n   * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n   * ```\n   */\n\n\n  requestSignIn(_ref) {\n    let {\n      contractId,\n      methodNames,\n      successUrl,\n      failureUrl\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentUrl = new URL(window.location.href);\n      const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n      newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n      newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n\n      if (contractId) {\n        /* Throws exception if contract account does not exist */\n        const contractAccount = yield this._near.account(contractId);\n        yield contractAccount.state();\n        newUrl.searchParams.set('contract_id', contractId);\n        const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n        newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n        yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n      }\n\n      if (methodNames) {\n        methodNames.forEach(methodName => {\n          newUrl.searchParams.append('methodNames', methodName);\n        });\n      }\n\n      window.location.assign(newUrl.toString());\n    });\n  }\n  /**\n   * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.\n   */\n\n\n  requestSignTransactions(_ref2) {\n    let {\n      transactions,\n      meta,\n      callbackUrl\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentUrl = new URL(window.location.href);\n      const newUrl = new URL('sign', this._walletBaseUrl);\n      newUrl.searchParams.set('transactions', transactions.map(transaction => (0, borsh_2.serialize)(transaction_1.SCHEMA, transaction)).map(serialized => Buffer.from(serialized).toString('base64')).join(','));\n      newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n      if (meta) newUrl.searchParams.set('meta', meta);\n      window.location.assign(newUrl.toString());\n    });\n  }\n  /**\n   * @hidden\n   * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n   */\n\n\n  _completeSignInWithAccessKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const currentUrl = new URL(window.location.href);\n      const publicKey = currentUrl.searchParams.get('public_key') || '';\n      const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n      const accountId = currentUrl.searchParams.get('account_id') || ''; // TODO: Handle errors during login\n\n      if (accountId) {\n        const authData = {\n          accountId,\n          allKeys\n        };\n        window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));\n\n        if (publicKey) {\n          yield this._moveKeyFromTempToPermanent(accountId, publicKey);\n        }\n\n        this._authData = authData;\n      }\n\n      currentUrl.searchParams.delete('public_key');\n      currentUrl.searchParams.delete('all_keys');\n      currentUrl.searchParams.delete('account_id');\n      currentUrl.searchParams.delete('meta');\n      currentUrl.searchParams.delete('transactionHashes');\n      window.history.replaceState({}, document.title, currentUrl.toString());\n    });\n  }\n  /**\n   * @hidden\n   * @param accountId The NEAR account owning the given public key\n   * @param publicKey The public key being set to the key store\n   */\n\n\n  _moveKeyFromTempToPermanent(accountId, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n      yield this._keyStore.setKey(this._networkId, accountId, keyPair);\n      yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    });\n  }\n  /**\n   * Sign out from the current account\n   * @example\n   * walletConnection.signOut();\n   */\n\n\n  signOut() {\n    this._authData = {};\n    window.localStorage.removeItem(this._authDataKey);\n  }\n  /**\n   * Returns the current connected wallet account\n   */\n\n\n  account() {\n    if (!this._connectedAccount) {\n      this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n    }\n\n    return this._connectedAccount;\n  }\n\n}\n\nexports.WalletConnection = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\n\nclass ConnectedWalletAccount extends account_1.Account {\n  constructor(walletConnection, connection, accountId) {\n    super(connection, accountId);\n    this.walletConnection = walletConnection;\n  } // Overriding Account methods\n\n  /**\n   * Sign a transaction by redirecting to the NEAR Wallet\n   * @see {@link WalletConnection.requestSignTransactions}\n   */\n\n\n  signAndSendTransaction(_ref3) {\n    let {\n      receiverId,\n      actions,\n      walletMeta,\n      walletCallbackUrl = window.location.href\n    } = _ref3;\n\n    const _super = Object.create(null, {\n      signAndSendTransaction: {\n        get: () => super.signAndSendTransaction\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n      let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);\n\n      if (!accessKey) {\n        throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n      }\n\n      if (localKey && localKey.toString() === accessKey.public_key) {\n        try {\n          return yield _super.signAndSendTransaction.call(this, {\n            receiverId,\n            actions\n          });\n        } catch (e) {\n          if (e.type === 'NotEnoughAllowance') {\n            accessKey = yield this.accessKeyForTransaction(receiverId, actions);\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      const block = yield this.connection.provider.block({\n        finality: 'final'\n      });\n      const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\n      const publicKey = utils_1.PublicKey.from(accessKey.public_key); // TODO: Cache & listen for nonce updates for given access key\n\n      const nonce = accessKey.access_key.nonce + 1;\n      const transaction = (0, transaction_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n      yield this.walletConnection.requestSignTransactions({\n        transactions: [transaction],\n        meta: walletMeta,\n        callbackUrl: walletCallbackUrl\n      });\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          reject(new Error('Failed to redirect to sign transaction'));\n        }, 1000);\n      }); // TODO: Aggregate multiple transaction request with \"debounce\".\n      // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    });\n  }\n  /**\n   * Check if given access key allows the function call or method attempted in transaction\n   * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n   * @param receiverId The NEAR account attempting to have access\n   * @param actions The action(s) needed to be checked for access\n   */\n\n\n  accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        access_key: {\n          permission\n        }\n      } = accessKey;\n\n      if (permission === 'FullAccess') {\n        return true;\n      }\n\n      if (permission.FunctionCall) {\n        const {\n          receiver_id: allowedReceiverId,\n          method_names: allowedMethods\n        } = permission.FunctionCall;\n        /********************************\n        Accept multisig access keys and let wallets attempt to signAndSendTransaction\n        If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n        ********************************/\n\n        if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n          return true;\n        }\n\n        if (allowedReceiverId === receiverId) {\n          if (actions.length !== 1) {\n            return false;\n          }\n\n          const [{\n            functionCall\n          }] = actions;\n          return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && ( // TODO: Should support charging amount smaller than allowance?\n          allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)); // TODO: Handle cases when allowance doesn't have enough to pay for gas\n        }\n      } // TODO: Support other permissions than FunctionCall\n\n\n      return false;\n    });\n  }\n  /**\n   * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n   * @param receiverId The NEAR account seeking the access key for a transaction\n   * @param actions The action(s) sought to gain access to\n   * @param localKey A local public key provided to check for access\n   * @returns Promise<any>\n   */\n\n\n  accessKeyForTransaction(receiverId, actions, localKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessKeys = yield this.getAccessKeys();\n\n      if (localKey) {\n        const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n\n        if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n          return accessKey;\n        }\n      }\n\n      const walletKeys = this.walletConnection._authData.allKeys;\n\n      for (const accessKey of accessKeys) {\n        if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n          return accessKey;\n        }\n      }\n\n      return null;\n    });\n  }\n\n}\n\nexports.ConnectedWalletAccount = ConnectedWalletAccount;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","ConnectedWalletAccount","WalletConnection","account_1","require","transaction_1","utils_1","borsh_1","borsh_2","LOGIN_WALLET_URL_SUFFIX","MULTISIG_HAS_METHOD","LOCAL_STORAGE_KEY_SUFFIX","PENDING_ACCESS_KEY_PREFIX","constructor","near","appKeyPrefix","window","Proxy","get","target","property","Error","_near","authDataKey","authData","JSON","parse","localStorage","getItem","_networkId","config","networkId","_walletBaseUrl","walletUrl","contractName","_keyStore","connection","signer","keyStore","_authData","allKeys","_authDataKey","isSignedIn","_completeSignInPromise","_completeSignInWithAccessKey","accountId","isSignedInAsync","getAccountId","requestSignIn","contractId","methodNames","successUrl","failureUrl","currentUrl","URL","location","href","newUrl","searchParams","set","contractAccount","account","state","accessKey","KeyPair","fromRandom","getPublicKey","toString","setKey","forEach","methodName","append","assign","requestSignTransactions","transactions","meta","callbackUrl","map","transaction","serialize","SCHEMA","serialized","Buffer","from","join","publicKey","split","setItem","stringify","_moveKeyFromTempToPermanent","delete","history","replaceState","document","title","keyPair","getKey","removeKey","signOut","removeItem","_connectedAccount","Account","walletConnection","signAndSendTransaction","receiverId","actions","walletMeta","walletCallbackUrl","_super","create","localKey","accessKeyForTransaction","public_key","call","type","block","provider","finality","blockHash","baseDecode","header","hash","PublicKey","nonce","access_key","createTransaction","setTimeout","accessKeyMatchesTransaction","permission","FunctionCall","receiver_id","allowedReceiverId","method_names","allowedMethods","includes","length","functionCall","deposit","accessKeys","getAccessKeys","find","key","walletKeys","indexOf"],"sources":["/Users/loyanix/projects/smart-hamster-web-app/node_modules/near-api-js/lib/wallet-account.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectedWalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst borsh_1 = require(\"borsh\");\nconst borsh_2 = require(\"borsh\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSignedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        if (typeof window === 'undefined') {\n            return new Proxy(this, {\n                get(target, property) {\n                    if (property === 'isSignedIn') {\n                        return () => false;\n                    }\n                    if (property === 'getAccountId') {\n                        return () => '';\n                    }\n                    if (target[property] && typeof target[property] === 'function') {\n                        return () => {\n                            throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');\n                        };\n                    }\n                    return target[property];\n                }\n            });\n        }\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInPromise = this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletConnection is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns promise of completing signing in after redirecting from wallet\n     * @example\n     * ```js\n     * // on login callback page\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn(); // false\n     * await wallet.isSignedInAsync(); // true\n     * ```\n     */\n    isSignedInAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._completeSignInPromise) {\n                return this.isSignedIn();\n            }\n            yield this._completeSignInPromise;\n            return this.isSignedIn();\n        });\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    requestSignIn({ contractId, methodNames, successUrl, failureUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n            newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n            newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n            if (contractId) {\n                /* Throws exception if contract account does not exist */\n                const contractAccount = yield this._near.account(contractId);\n                yield contractAccount.state();\n                newUrl.searchParams.set('contract_id', contractId);\n                const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n                newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n                yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n            }\n            if (methodNames) {\n                methodNames.forEach(methodName => {\n                    newUrl.searchParams.append('methodNames', methodName);\n                });\n            }\n            window.location.assign(newUrl.toString());\n        });\n    }\n    /**\n     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.\n     */\n    requestSignTransactions({ transactions, meta, callbackUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const newUrl = new URL('sign', this._walletBaseUrl);\n            newUrl.searchParams.set('transactions', transactions\n                .map(transaction => (0, borsh_2.serialize)(transaction_1.SCHEMA, transaction))\n                .map(serialized => Buffer.from(serialized).toString('base64'))\n                .join(','));\n            newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n            if (meta)\n                newUrl.searchParams.set('meta', meta);\n            window.location.assign(newUrl.toString());\n        });\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    _completeSignInWithAccessKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const publicKey = currentUrl.searchParams.get('public_key') || '';\n            const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n            const accountId = currentUrl.searchParams.get('account_id') || '';\n            // TODO: Handle errors during login\n            if (accountId) {\n                const authData = {\n                    accountId,\n                    allKeys\n                };\n                window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));\n                if (publicKey) {\n                    yield this._moveKeyFromTempToPermanent(accountId, publicKey);\n                }\n                this._authData = authData;\n            }\n            currentUrl.searchParams.delete('public_key');\n            currentUrl.searchParams.delete('all_keys');\n            currentUrl.searchParams.delete('account_id');\n            currentUrl.searchParams.delete('meta');\n            currentUrl.searchParams.delete('transactionHashes');\n            window.history.replaceState({}, document.title, currentUrl.toString());\n        });\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    _moveKeyFromTempToPermanent(accountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n            yield this._keyStore.setKey(this._networkId, accountId, keyPair);\n            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        });\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletConnection.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection.requestSignTransactions}\n     */\n    signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);\n            if (!accessKey) {\n                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n            }\n            if (localKey && localKey.toString() === accessKey.public_key) {\n                try {\n                    return yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n                }\n                catch (e) {\n                    if (e.type === 'NotEnoughAllowance') {\n                        accessKey = yield this.accessKeyForTransaction(receiverId, actions);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = (0, borsh_1.baseDecode)(block.header.hash);\n            const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n            // TODO: Cache & listen for nonce updates for given access key\n            const nonce = accessKey.access_key.nonce + 1;\n            const transaction = (0, transaction_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n            yield this.walletConnection.requestSignTransactions({\n                transactions: [transaction],\n                meta: walletMeta,\n                callbackUrl: walletCallbackUrl\n            });\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    reject(new Error('Failed to redirect to sign transaction'));\n                }, 1000);\n            });\n            // TODO: Aggregate multiple transaction request with \"debounce\".\n            // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n        });\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { access_key: { permission } } = accessKey;\n            if (permission === 'FullAccess') {\n                return true;\n            }\n            if (permission.FunctionCall) {\n                const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n                /********************************\n                Accept multisig access keys and let wallets attempt to signAndSendTransaction\n                If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n                ********************************/\n                if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                    return true;\n                }\n                if (allowedReceiverId === receiverId) {\n                    if (actions.length !== 1) {\n                        return false;\n                    }\n                    const [{ functionCall }] = actions;\n                    return functionCall &&\n                        (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                        (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                    // TODO: Handle cases when allowance doesn't have enough to pay for gas\n                }\n            }\n            // TODO: Support other permissions than FunctionCall\n            return false;\n        });\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n    accessKeyForTransaction(receiverId, actions, localKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeys = yield this.getAccessKeys();\n            if (localKey) {\n                const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n                if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            const walletKeys = this.walletConnection._authData.allKeys;\n            for (const accessKey of accessKeys) {\n                if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            return null;\n        });\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}